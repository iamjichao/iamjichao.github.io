<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="https://fehub.net/feed.xml" rel="self" type="application/atom+xml" /><link href="https://fehub.net/" rel="alternate" type="text/html" /><updated>2024-03-29T22:21:46+08:00</updated><id>https://fehub.net/feed.xml</id><title type="html">FEHub</title><subtitle></subtitle><author><name>Ji Chao</name></author><entry><title type="html">我对 AI 的思考</title><link href="https://fehub.net/2023/04/23/about-ai/" rel="alternate" type="text/html" title="我对 AI 的思考" /><published>2023-04-23T00:00:00+08:00</published><updated>2023-04-23T00:00:00+08:00</updated><id>https://fehub.net/2023/04/23/about-ai</id><content type="html" xml:base="https://fehub.net/2023/04/23/about-ai/"><![CDATA[<blockquote>
  <p>2023 年 3 月 14 日，OpenAI 宣布正式发布 GPT-4，它拥有图像识别、高级推理、庞大的单词掌握能力，并可以用所有流行的编程语言写代码。</p>
</blockquote>

<p>1776 年，一位纺织厂的女工听说一个叫瓦特的发明家改良了蒸汽机，已经应用于生产，于是她开始担忧在不久的将来，自己的工作将会被蒸汽机取代。9 年后的 1785 年，瓦特的改良蒸汽机开始用作纺织机械的动力，并很快推广开来，引起了第一次技术和工业革命的高潮，人类从此进入了机器和蒸汽的时代。由此而来的不是失业和萧条，而是社会生产力的大幅提升，一些职业被消灭的同时又出现了更多的新职业，人们的生活水平也水涨船高。</p>

<p>2022 年，OpenAI 发布了 ChatGPT，经过多个版本的迭代，ChatGPT 已经可以根据用户的输入生成各种各样的文本，包括代码。此时，一个新时代的流水线码农开始担忧在不久的将来，AI 将会取代自己的工作，想到自己的房贷、车贷和嗷嗷待哺的孩子，他对未来的不确定性充满悲观。</p>

<p>毫无疑问，我们已经身处又一次技术革命的浪潮中，而这次的主角就是 AI。AI 对人类社会会产生怎样的影响，我们现在还没办法预测，但可以肯定的是，技术革命必然会带来生产力的提升，生产力的提升又会创造更多的工作岗位，因此我认为，我们没有必要杞人忧天，担忧未来不确定的失业问题。虽然 AI 在不久的将来可能会取代程序员的工作，但同时它也会创造出更多新的工作岗位。例如，AI 训练师，训练 AI 模型，使其更好地理解和执行任务；AI 维护工程师，保证 AI 系统的正常运行。我们应该把 AI 看作是一个机会，而不是威胁。</p>

<p>事物都是不断发展，不断变化的，我们需要的是拥抱变化，不断学习的能力。保持对新事物的好奇，积极学习新的技能，是我们面对未来最好的武器。</p>]]></content><author><name>Ji Chao</name></author><category term="Blog" /><summary type="html"><![CDATA[我对 AI 的思考]]></summary></entry><entry><title type="html">网站换肤的正确打开方式</title><link href="https://fehub.net/2022/06/25/website-skin/" rel="alternate" type="text/html" title="网站换肤的正确打开方式" /><published>2022-06-25T00:00:00+08:00</published><updated>2022-06-25T00:00:00+08:00</updated><id>https://fehub.net/2022/06/25/website-skin</id><content type="html" xml:base="https://fehub.net/2022/06/25/website-skin/"><![CDATA[<p>网站换肤是一个常见的前端需求，比如切换日间和夜间模式。它的思路很简单，就是通过加载不同的 CSS 让页面显示不同的样式。实现方法有很多，但效果不尽相同。</p>

<h3 id="常见的网站换肤实现">常见的网站换肤实现</h3>

<ul>
  <li>一个全局的 class 控制样式切换</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.default.light</span> <span class="p">{</span>
   <span class="nl">background</span><span class="p">:</span> <span class="no">white</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.dark</span> <span class="p">{</span>
   <span class="nl">background</span><span class="p">:</span> <span class="no">gray</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个方法的缺点是代码啰嗦，优先级不好控制，维护成本高，不推荐。</p>

<ul>
  <li>改变 <code class="language-plaintext highlighter-rouge">link</code> 元素的 <code class="language-plaintext highlighter-rouge">href</code> 地址</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">id=</span><span class="s">"skin"</span> <span class="na">href=</span><span class="s">"default.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p>通过 JS 改变 <code class="language-plaintext highlighter-rouge">href</code> 地址：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#skin</span><span class="dl">'</span><span class="p">).</span><span class="nx">href</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">dark.css</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p>这个方法的缺点是有延迟，切换不流畅。</p>

<h3 id="使用原生-html-特性实现流畅的换肤效果">使用原生 HTML 特性实现流畅的换肤效果</h3>

<p>首先了解一下 <code class="language-plaintext highlighter-rouge">link</code> 标签的 <code class="language-plaintext highlighter-rouge">rel</code> <code class="language-plaintext highlighter-rouge">title</code> <code class="language-plaintext highlighter-rouge">disabled</code> 属性，详细内容参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link">&lt;link&gt;：外部资源链接元素</a>。</p>

<ul>
  <li>rel 属性用于声明链接文档与当前文档的关系，属性值参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types">链接类型值</a>，多个用空格分隔。</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"alternate stylesheet"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>title 属性用于 <code class="language-plaintext highlighter-rouge">&lt;link rel="stylesheet"&gt;</code> 时会定义一个首选样式表或备用样式表。</p>
  </li>
  <li>
    <p>disabled 属性仅用于 <code class="language-plaintext highlighter-rouge">&lt;link rel="stylesheet"&gt;</code>，控制是否加载并应用所描述的样式表。如果指定了 <code class="language-plaintext highlighter-rouge">disabled</code>，在页面加载期间不会加载此样式表。如果将 <code class="language-plaintext highlighter-rouge">disabled</code> 属性更改为 <code class="language-plaintext highlighter-rouge">false</code> 或删除，样式表将按需加载。</p>
  </li>
</ul>

<p>网页中的样式表分为三类：</p>

<ul>
  <li>
    <p>Persistent (no rel=”alternate”, no title)：总是应用。</p>
  </li>
  <li>
    <p>Preferred (no rel=”alternate”, with title=”…”)：默认应用，如果选择了另一个样式表则禁用。只能有一个首选样式表，多个不同标题的样式表只能生效一个。</p>
  </li>
  <li>
    <p>Alternate (rel=”alternate stylesheet”, title=”…”)：默认禁用，可以选择。</p>
  </li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 加载并渲染，总是应用 --&gt;</span>
<span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"basic.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- 加载并渲染，默认应用 --&gt;</span>
<span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"default.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">title=</span><span class="s">"Default"</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- 只加载不渲染，备用可选 --&gt;</span>
<span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"light.css"</span> <span class="na">rel=</span><span class="s">"alternate stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">title=</span><span class="s">"Light"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"dark.css"</span> <span class="na">rel=</span><span class="s">"alternate stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">title=</span><span class="s">"Dark"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p>通过 JS 控制 <code class="language-plaintext highlighter-rouge">link</code> 元素的 <code class="language-plaintext highlighter-rouge">disabled</code> 属性来启用和禁用样式表：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 启用</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">link[href="light.css"]</span><span class="dl">'</span><span class="p">).</span><span class="nx">disabled</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

<span class="c1">// 禁用</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">link[href="light.css"]</span><span class="dl">'</span><span class="p">).</span><span class="nx">disabled</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div>

<p>这个方法兼容性很好，切换不会有延迟，交互体验更好，推荐使用。</p>

<p>以上。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
  <li><a href="https://b23.tv/PLImiGs">网站换肤的最佳实现 - 哔哩哔哩</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link">&lt;link&gt;：外部资源链接元素 - MDN</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types">链接类型 - MDN</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Alternative_style_sheets">Alternative style sheets - MDN</a></li>
</ul>]]></content><author><name>Ji Chao</name></author><category term="HTML" /><category term="CSS" /><summary type="html"><![CDATA[网站换肤的正确打开方式]]></summary></entry><entry><title type="html">与用户行为相关的 CSS 属性</title><link href="https://fehub.net/2022/05/28/user-behavior-css/" rel="alternate" type="text/html" title="与用户行为相关的 CSS 属性" /><published>2022-05-28T00:00:00+08:00</published><updated>2022-05-28T00:00:00+08:00</updated><id>https://fehub.net/2022/05/28/user-behavior-css</id><content type="html" xml:base="https://fehub.net/2022/05/28/user-behavior-css/"><![CDATA[<p>CSS 中有几个和用户行为密切相关的属性，虽然平时不怎么用，但要知道有这几个东西，以备不时之需。</p>

<h3 id="user-select">user-select</h3>

<blockquote>
  <p>CSS 属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/user-select">user-select</a> 控制用户能否选中文本。</p>
</blockquote>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">user-select</span><span class="o">:</span> <span class="nt">none</span><span class="o">;</span> <span class="c">/* 文本不可选中 */</span>
<span class="nt">user-select</span><span class="o">:</span> <span class="nt">auto</span><span class="o">;</span> <span class="c">/* 自动 */</span>
<span class="nt">user-select</span><span class="o">:</span> <span class="nt">text</span><span class="o">;</span> <span class="c">/* 文本可选中 */</span>
<span class="nt">user-select</span><span class="o">:</span> <span class="nt">all</span><span class="o">;</span> <span class="c">/* 元素及其子元素会全部被选中 */</span>
<span class="nt">user-select</span><span class="o">:</span> <span class="nt">contain</span><span class="o">;</span> <span class="c">/* 允许在元素内选择 */</span>
</code></pre></div></div>

<p>我们常实现的禁止文本复制功能，手机端会设置如下 CSS 代码，此时整个页面无法通过长按唤起系统自带的复制等操作：</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">body</span> <span class="p">{</span>
  <span class="nl">-webkit-user-select</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
  <span class="nl">-moz-user-select</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
  <span class="nl">-ms-user-select</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
  <span class="py">user-select</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个属性的兼容性还不错，可以放心使用。</p>

<p><img src="https://fehub.net/images/posts/2022/user-behavior-css-1.png" alt="image" /></p>

<h3 id="user-drag">user-drag</h3>

<blockquote>
  <p>CSS 属性 -webkit-user-drag 控制用户拖拽行为。</p>
</blockquote>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-webkit-user-drag</span><span class="o">:</span> <span class="nt">none</span><span class="o">;</span> <span class="c">/* 图片文字可拖拽 */</span>
<span class="nt">-webkit-user-drag</span><span class="o">:</span> <span class="nt">auto</span><span class="o">;</span> <span class="c">/* 图片文字不可拖拽 */</span>
<span class="nt">-webkit-user-drag</span><span class="o">:</span> <span class="nt">text</span><span class="o">;</span> <span class="c">/* 元素可拖拽 Safari only */</span>
</code></pre></div></div>

<p>设置图片不可拖拽：</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="nc">.no-drag</span> <span class="p">{</span>
  <span class="nl">-webkit-user-drag</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个属性兼容性不好，要谨慎使用。</p>

<p><img src="https://fehub.net/images/posts/2022/user-behavior-css-2.png" alt="image" /></p>

<p>如果有相关需求可以使用 HTML 元素的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/draggable"><code class="language-plaintext highlighter-rouge">draggable</code></a> 属性实现：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 元素可以拖拽 --&gt;</span>
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"demo.png"</span> <span class="na">draggable=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- 元素不可以拖拽 --&gt;</span>
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"demo.png"</span> <span class="na">draggable=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<h3 id="user-modify">user-modify</h3>

<p>CSS 属性 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/user-modify">user-modify</a> 控制元素的内容是否可以由用户编辑。</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">user-modify</span><span class="o">:</span> <span class="nt">read-only</span><span class="o">;</span> <span class="c">/* 内容只读 */</span>
<span class="nt">user-modify</span><span class="o">:</span> <span class="nt">read-write</span><span class="o">;</span> <span class="c">/* 用户能够读取和写入内容，支持富文本 */</span>
<span class="nt">user-modify</span><span class="o">:</span> <span class="nt">read-write-plaintext-only</span><span class="o">;</span> <span class="c">/* 用户能够读取和写入内容，但富文本格式将丢失 */</span>
<span class="nt">user-modify</span><span class="o">:</span> <span class="nt">write-only</span><span class="o">;</span> <span class="c">/* 用户可以编辑内容，但不能阅读 */</span>
</code></pre></div></div>

<p>这个属性的兼容性还不错，但它不是标准语法，可能会从相关的 Web 标准中删除，不再推荐使用此功能。</p>

<p><img src="https://fehub.net/images/posts/2022/user-behavior-css-3.png" alt="image" /></p>

<p>如果有相关需求可以使用 HTML 元素的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable"><code class="language-plaintext highlighter-rouge">contenteditable</code></a> 属性实现：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 元素可编辑 --&gt;</span>
<span class="nt">&lt;div</span> <span class="na">contenteditable=</span><span class="s">"true"</span><span class="nt">&gt;&lt;/div&gt;</span>

<span class="c">&lt;!-- 元素可编辑，只能输入纯文本 --&gt;</span>
<span class="nt">&lt;div</span> <span class="na">contenteditable=</span><span class="s">"plaintext-only"</span><span class="nt">&gt;&lt;/div&gt;</span>

<span class="c">&lt;!-- 元素不可编辑 --&gt;</span>
<span class="nt">&lt;div</span> <span class="na">contenteditable=</span><span class="s">"false"</span><span class="nt">&gt;&lt;/div&gt;</span>
</code></pre></div></div>

<p>以上。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
  <li><a href="https://b23.tv/C17dK3j">用户行为CSS三剑客 - 哔哩哔哩</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/user-select">user-select CSS - MDN</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/user-modify">user-modify CSS - MDN</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/draggable">draggable HTML - MDN</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable">contenteditable HTML - MDN</a></li>
</ul>]]></content><author><name>Ji Chao</name></author><category term="CSS" /><summary type="html"><![CDATA[与用户行为相关的 CSS 属性]]></summary></entry><entry><title type="html">网页设置全局字体的正确打开方式</title><link href="https://fehub.net/2022/05/21/global-font/" rel="alternate" type="text/html" title="网页设置全局字体的正确打开方式" /><published>2022-05-21T00:00:00+08:00</published><updated>2022-05-21T00:00:00+08:00</updated><id>https://fehub.net/2022/05/21/global-font</id><content type="html" xml:base="https://fehub.net/2022/05/21/global-font/"><![CDATA[<p>最近看了张鑫旭大神关于网页全局字体的视频，突然意识到我们前端项目中的全局字体设置似乎都是一代一代继承下来的，平时也不会太在意这些 CSS 代码，但仔细研究一下发现还是有很多问题的。</p>

<p>进入正题。</p>

<h3 id="font-family">font-family</h3>

<blockquote>
  <p>CSS 属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family">font-family</a> 允许通过给定一个有先后顺序的由字体名或者字体族名组成的列表来为选定的元素设置字体，属性值用逗号隔开。浏览器会选择列表中第一个该计算机上有安装的字体，或者是通过 @font-face 指定的可以直接下载的字体。</p>
</blockquote>

<h3 id="font-face">@font-face</h3>

<blockquote>
  <p>CSS at-rule <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">@font-face</a> 指定一个用于显示文本的自定义字体，字体能从远程服务器或者用户本地安装的字体中加载。如果提供了 local() 函数，从用户本地查找指定的字体名称，并且找到了一个匹配项，本地字体就会被使用，否则字体就会使用 url() 函数下载的资源。</p>
</blockquote>

<h3 id="在项目中的应用">在项目中的应用</h3>

<p>我们通常会给页面的根元素设置 font-family 属性来指定全局字体，但是不同系统对于字体的支持效果不同，比如苹果系统中的苹方字体在 Windows 系统的 1 倍屏下是瘦的，而且边缘模糊。</p>

<p>对于同一系统来说，不同版本的系统字体也有所不同，比如 macOS：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">macOS 版本</th>
      <th style="text-align: left">系统字体</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">10.11</td>
      <td style="text-align: left">San Francisco</td>
    </tr>
    <tr>
      <td style="text-align: left">10.9</td>
      <td style="text-align: left">Lucida Grande</td>
    </tr>
    <tr>
      <td style="text-align: left">10.1</td>
      <td style="text-align: left">Helvetica Neue</td>
    </tr>
  </tbody>
</table>

<p>如果给 font-family 设置一种具体的字体，不仅可能不适配不同系统，而且在系统升级时，网页将无法享受字体升级的体验，所以全局字体应该设置成系统字体，不要指定具体的字体。</p>

<p>全局字体 font-family 应该包含：</p>

<ul>
  <li>系统字体</li>
  <li>兜底字体：系统字体不支持时使用的字体</li>
  <li>Emoji 字体：支持彩色的 emoji 表情 👉 😏😳😱</li>
</ul>

<h3 id="怎样设置全局字体">怎样设置全局字体</h3>

<p>直接上干货：</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* font-family 最佳设置 */</span>
<span class="k">@font-face</span> <span class="p">{</span>
  <span class="nl">font-family</span><span class="p">:</span> <span class="n">Emoji</span><span class="p">;</span>
  <span class="nl">src</span><span class="p">:</span>
    <span class="n">local</span><span class="p">(</span><span class="s1">"Apple Color Emojiji"</span><span class="p">),</span> <span class="c">/* macOS/iOS */</span>
    <span class="n">local</span><span class="p">(</span><span class="s1">"Segoe UI Emoji"</span><span class="p">),</span> <span class="c">/* Windows8.1/10 */</span>
    <span class="n">local</span><span class="p">(</span><span class="s1">"Segoe UI Symbol"</span><span class="p">),</span> <span class="c">/* windows7/8 */</span>
    <span class="n">local</span><span class="p">(</span><span class="s1">"Noto Color Emoji"</span><span class="p">);</span> <span class="c">/* Android */</span>
  <span class="py">unicode-range</span><span class="p">:</span> <span class="n">U</span><span class="err">+</span><span class="m">1</span><span class="n">F000-1F644</span><span class="p">,</span> <span class="n">U</span><span class="err">+</span><span class="m">203</span><span class="n">C-3299</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">html</span> <span class="p">{</span>
  <span class="nl">font-family</span><span class="p">:</span>
    <span class="n">system-ui</span><span class="p">,</span> <span class="c">/* 最新规范的系统字体 Chrome/Safari */</span>
    <span class="err">—</span><span class="n">apple-system</span><span class="p">,</span> <span class="c">/* 系统字体 macOS 下的 FireFox */</span>
    <span class="n">Segoe</span> <span class="n">UI</span><span class="p">,</span> <span class="c">/* 兜底字体 Windows */</span>
    <span class="n">Rototo</span><span class="p">,</span> <span class="c">/* 兜底字体 Android */</span>
    <span class="n">Emoji</span><span class="p">,</span> <span class="c">/* Emoji 自定义字体 */</span>
    <span class="n">Helvetica</span><span class="p">,</span> <span class="c">/* 兜底字体 macOS/iOS */</span>
    <span class="n">Arial</span><span class="p">,</span> <span class="c">/* 兜底字体 old Windows */</span>
    <span class="nb">sans-serif</span><span class="p">;</span> <span class="c">/* 兜底字体 old Android */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意 Emoji 字体的位置，因为 Helvetica 和 Arial 字体的 Unicode 范围会覆盖 Emoji 字体，所以要把 Emoji 字体放在它们前边。把 Emoji 字体放在最前边也会有问题，因为可能会覆盖其他普通字体，这时可以通过 @font-face 中的 unicode-range 来限制 Emoji 字体作用的字符范围，即 Unicode 在此范围内时可以使用 Emoji 字体。</p>

<p>还有一些其他字体的设置：</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* 衬线字体 */</span>
<span class="nc">.font-serif</span> <span class="p">{</span>
  <span class="nl">font-family</span><span class="p">:</span> <span class="n">Georgia</span><span class="p">,</span> <span class="n">Cambria</span><span class="p">,</span> <span class="s1">"Times New Roman"</span><span class="p">,</span> <span class="n">Times</span><span class="p">,</span> <span class="nb">serif</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 等宽字体 */</span>
<span class="nc">.font-mono</span> <span class="p">{</span>
  <span class="nl">font-family</span><span class="p">:</span> <span class="n">Menlo</span><span class="p">,</span> <span class="n">Monaco</span><span class="p">,</span> <span class="n">Consolas</span><span class="p">,</span> <span class="s1">"Liberation Mono"</span><span class="p">,</span> <span class="s1">"Courier New"</span><span class="p">,</span> <span class="nb">monospace</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="举一反三">举一反三</h3>

<ul>
  <li>通用字体 generic-name 是某一类字体的统称，它又包括多个字体族。在 font-family 列表的末尾应该至少有一个通用字体族名，这是一种备选机制，可以在指定的字体不可用时显示较好的字体。</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">通用字体族名</th>
      <th style="text-align: left">字体</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">serif</td>
      <td style="text-align: left">带衬线字体</td>
    </tr>
    <tr>
      <td style="text-align: left">sans-serif</td>
      <td style="text-align: left">无衬线字体</td>
    </tr>
    <tr>
      <td style="text-align: left">monospace</td>
      <td style="text-align: left">等宽字体</td>
    </tr>
    <tr>
      <td style="text-align: left">cursive</td>
      <td style="text-align: left">草书字体</td>
    </tr>
    <tr>
      <td style="text-align: left">fantasy</td>
      <td style="text-align: left">具有特殊艺术效果的字体</td>
    </tr>
    <tr>
      <td style="text-align: left">system-ui</td>
      <td style="text-align: left">从浏览器所处平台处获取的默认用户界面字体</td>
    </tr>
    <tr>
      <td style="text-align: left">math</td>
      <td style="text-align: left">针对显示数学相关字符的特殊样式问题而设计的字体</td>
    </tr>
    <tr>
      <td style="text-align: left">emoji</td>
      <td style="text-align: left">专门用于呈现 Emoji 表情符号的字体</td>
    </tr>
    <tr>
      <td style="text-align: left">fangsong</td>
      <td style="text-align: left">一种汉字字体</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>在 font-family 列表中，字体族名如果包含空格，应该加引号。</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">font-family</span><span class="o">:</span> <span class="s1">"Gill Sans Extrabold"</span><span class="o">,</span> <span class="nt">sans-serif</span><span class="o">;</span>
</code></pre></div></div>

<p>以上。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
  <li><a href="https://b23.tv/8zYhEob">网页的默认全局字体该如何设置？- 哔哩哔哩</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family">font-family CSS - MDN</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">@font-face CSS - MDN</a></li>
</ul>]]></content><author><name>Ji Chao</name></author><category term="CSS" /><summary type="html"><![CDATA[网页设置全局字体的正确打开方式]]></summary></entry><entry><title type="html">一次搞懂原型和原型链</title><link href="https://fehub.net/2021/06/06/prototype/" rel="alternate" type="text/html" title="一次搞懂原型和原型链" /><published>2021-06-06T00:00:00+08:00</published><updated>2021-06-06T00:00:00+08:00</updated><id>https://fehub.net/2021/06/06/prototype</id><content type="html" xml:base="https://fehub.net/2021/06/06/prototype/"><![CDATA[<h2 id="有图有真相">有图有真相</h2>

<p><img src="https://fehub.net/images/posts/2021/prototype.png" alt="image" /></p>

<h2 id="真想只有一个">真想只有一个</h2>

<ul>
  <li>构造函数 <code class="language-plaintext highlighter-rouge">Person</code>，通过 <code class="language-plaintext highlighter-rouge">new</code> 实例化它的一个实例 <code class="language-plaintext highlighter-rouge">person</code>，实例 <code class="language-plaintext highlighter-rouge">person</code> 的原型就是构造函数 <code class="language-plaintext highlighter-rouge">Person</code> 的 <code class="language-plaintext highlighter-rouge">prototype</code> 属性，即 <code class="language-plaintext highlighter-rouge">Person.prototype</code>。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 构造函数</span>
<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">()</span> <span class="c1">// 实例</span>
<span class="c1">// person的原型 === Person.prototype</span>
</code></pre></div></div>

<ul>
  <li>实例的原型 <code class="language-plaintext highlighter-rouge">Person.prototype</code> 通过 <code class="language-plaintext highlighter-rouge">constructor</code> 属性可以访问到构造函数 <code class="language-plaintext highlighter-rouge">Person</code>，也就是实例原型的 <code class="language-plaintext highlighter-rouge">constructor</code> 属性指向构造函数。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Person</span>
</code></pre></div></div>

<ul>
  <li>实例 <code class="language-plaintext highlighter-rouge">person</code> 通过 <code class="language-plaintext highlighter-rouge">__proto__</code> 属性可以访问到实例 <code class="language-plaintext highlighter-rouge">person</code> 的原型，也就是说实例的 <code class="language-plaintext highlighter-rouge">__proto__</code> 属性指向实例的原型。<code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 方法也可以返回指定对象的原型。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">person</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span>
</code></pre></div></div>

<ul>
  <li>实例的原型 <code class="language-plaintext highlighter-rouge">Person.prototype</code> 本身是一个对象，也就是说它是内置构造函数 <code class="language-plaintext highlighter-rouge">Object</code> 的一个实例，那么 <code class="language-plaintext highlighter-rouge">Person.prototype</code> 也可以通过 <code class="language-plaintext highlighter-rouge">__proto__</code> 属性或者 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 方法访问到它的原型。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Object.prototype</code> 是原型链的终点，所以通过 <code class="language-plaintext highlighter-rouge">__proto__</code> 属性或者 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 方法访问它的原型时是 <code class="language-plaintext highlighter-rouge">null</code>。试想，如果 <code class="language-plaintext highlighter-rouge">Object.prototype</code> 也是一个对象，那么它就可以通过 <code class="language-plaintext highlighter-rouge">__proto__</code> 属性或者 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf()</code> 方法访问到它的原型 <code class="language-plaintext highlighter-rouge">Object.prototype</code>，这样就变成了自己指向自己，陷入死循环了。<code class="language-plaintext highlighter-rouge">Object.prototype</code> 是由 JS 引擎创建的，而不是由构造函数 <code class="language-plaintext highlighter-rouge">Object</code> 创建的，没有继承任何属性。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="kc">null</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="o">===</span> <span class="kc">null</span>
</code></pre></div></div>

<p>以上。</p>]]></content><author><name>Ji Chao</name></author><category term="一次搞懂系列" /><category term="JavaScript" /><summary type="html"><![CDATA[一次搞懂原型和原型链]]></summary></entry><entry><title type="html">一次搞懂作用域和闭包</title><link href="https://fehub.net/2021/03/20/scope-closure/" rel="alternate" type="text/html" title="一次搞懂作用域和闭包" /><published>2021-03-20T00:00:00+08:00</published><updated>2021-03-20T00:00:00+08:00</updated><id>https://fehub.net/2021/03/20/scope-closure</id><content type="html" xml:base="https://fehub.net/2021/03/20/scope-closure/"><![CDATA[<blockquote>
  <p>对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，但需要付出非常多的努力和牺牲才能理解这个概念。</p>
</blockquote>

<blockquote>
  <p>闭包并不是一个需要学习新的语法或模式才能使用的工具，它也不是一件必须接受像 Luke 一样的原力训练才能使用和掌握的武器。理解闭包就好像 Neo 第一次见到矩阵一样。</p>
</blockquote>

<p>希望这篇文章可以像 Morpheus 一样，引导你去发现闭包这个神秘的矩阵。那么你选择蓝色药丸还是红色药丸？</p>

<h2 id="开胃小菜">开胃小菜</h2>

<h3 id="js-的编译">JS 的编译</h3>

<ol>
  <li>传统编译语言的编译步骤：词法分析、语法分析、代码生成。</li>
  <li>JS 虽然是一种解释型语言，是一门编译语言，代码片段在执行前（几微秒）进行编译。</li>
  <li>参与 JS 编译的角色：
    <ul>
      <li>引擎：负责整个 JS 的编译和执行过程</li>
      <li>编译器：负责语法分析和代码生成</li>
      <li>作用域：相当于一个容器，负责收集并维护所有标识符（变量、函数），确定代码对标识符的访问权限</li>
    </ul>
  </li>
</ol>

<h3 id="词法作用域">词法作用域</h3>

<ol>
  <li>作用域的模型有词法作用域和动态作用域，词法作用域就是定义在词法阶段的作用域。JS 采用的是词法作用域模型，编译的词法分析阶段会确定代码中全部的标识符在哪个作用域以及是如何声明的，从而预测执行时应该如何查找。</li>
  <li>JS中，除全局作用域外，函数声明以及代码块也会创建一个新的作用域，对应的词法作用域是由书写代码时函数声明或代码块的位置来决定的。作用域内声明的所有变量都会附属于这个作用域。</li>
  <li>作用域发生嵌套时，查找会从运行时所处的作用域开始，逐级向上进行，直到查到第一个匹配的标识符为止。</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Matrix</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Neo</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Morpheus</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">Matrix</span><span class="p">();</span>
<span class="c1">// 'Morpheus'</span>
<span class="c1">// 'Neo'</span>
</code></pre></div></div>

<h3 id="函数作用域">函数作用域</h3>

<ol>
  <li>函数声明把变量和函数包裹起来，变成属于自己作用域的私有变量或函数，这遵循了软件设计中的最小授权（最小暴露）原则，可以规避因命名冲突导致的变量值被覆盖。</li>
  <li>函数作用域的含义是，<strong>属于这个函数的全部变量都可以在整个函数的范围内（包括内部嵌套的作用域）使用</strong>。</li>
</ol>

<h3 id="块作用域">块作用域</h3>

<ol>
  <li>ES6 中新增的块作用域可以将代码在块中隐藏，是对最小授权原则的扩展。</li>
  <li>如果使用 var 在块作用域中声明变量，会被提升到外部作用域，并不能把变量隐藏在块作用域中，使用 es6 的 const/let 进行声明可以将变量绑定到所在的作用域中，不会被提升。</li>
</ol>

<p><img src="https://fehub.net/images/posts/2021/scope-closure-1.png" alt="image" /></p>

<ol>
  <li>常见的块作用域：
    <ul>
      <li>for 循环</li>
      <li>if 语句</li>
      <li>with</li>
      <li>try/catch 中的 catch</li>
      <li>{…}</li>
    </ul>
  </li>
</ol>

<h3 id="lhs-和-rhs-查询">LHS 和 RHS 查询</h3>

<ol>
  <li>LHS 查询是找到变量的容器，进而赋值（赋值操作的目标）</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>编译器判断变量 a 是否声明过，没有则在当前作用域下声明，有则忽略。这一步是在代码执行前进行。</li>
  <li>运行阶段，引擎通过 LHS 查询在作用域中找到变量 a。</li>
  <li>将 1 赋给该变量。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相当于两个语句</span>
<span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<ol>
  <li>RHS 查询是找到变量的值（赋值操作的源头）</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>对 a 进行 RHS 查询，取得 a 的值。</li>
  <li>将值传递给 console.log(a)。
    <ol>
      <li>LHS 和 RHS 查询都会从当前作用域开始查找，一级一级往上层作用域查找，找到则停止，一直到全局作用域。如果到全局作用域还没有找到，RHS 查询会抛出 <code class="language-plaintext highlighter-rouge">ReferenceError</code> 异常，LHS 查询在非严格模式下会自动创建一个全局变量，而在严格模式下也会抛出 <code class="language-plaintext highlighter-rouge">ReferenceError</code> 异常。</li>
    </ol>
  </li>
</ul>

<p><img src="https://fehub.net/images/posts/2021/scope-closure-2.png" alt="image" /></p>

<h3 id="变量提升">变量提升</h3>

<ol>
  <li>所有的声明（变量和函数）都会被移动到各自作用域的最上面，这个过程被称为提升。</li>
  <li>变量声明提升：
    <ul>
      <li>var 会提升</li>
      <li>const/let 不会提升</li>
    </ul>
  </li>
  <li>函数声明提升：
    <ul>
      <li>函数声明会被提升到变量之前</li>
      <li>函数表达式不会被提升</li>
    </ul>
  </li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// Uncaught ReferenceError: b is not defined</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="nx">c</span><span class="p">();</span> <span class="c1">// 1</span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">c</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">c</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="鸡汤来喽">鸡汤来喽</h2>

<h3 id="闭包到底是什么">闭包到底是什么</h3>

<blockquote>
  <p>闭包是基于词法作用域书写代码时所产生的自然结果。当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>

</blockquote>

<p>MDN 对 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包</a> 的定义是：</p>

<blockquote>
  <p>闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。</p>

</blockquote>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f1</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">f2</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">f2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">f1</span><span class="p">();</span>
<span class="nx">f</span><span class="p">();</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p>上述代码中，<code class="language-plaintext highlighter-rouge">f2</code> 可以访问 <code class="language-plaintext highlighter-rouge">f1</code> 的内部作用域，<code class="language-plaintext highlighter-rouge">f1()</code> 返回内部的 <code class="language-plaintext highlighter-rouge">f2</code> 函数，然后赋值给变量 <code class="language-plaintext highlighter-rouge">f</code> 并调用，实际上是 <code class="language-plaintext highlighter-rouge">f2</code> 在定义时的词法作用域外被调用。</p>

<p><code class="language-plaintext highlighter-rouge">f1</code> 执行后，通常情况下它的整个内部作用域会被引擎的垃圾回收机制销毁并释放内存。而在这段代码中，<code class="language-plaintext highlighter-rouge">f2</code> 作为 <code class="language-plaintext highlighter-rouge">f1()</code> 的返回值，<code class="language-plaintext highlighter-rouge">f1</code> 的内部作用域一直被 <code class="language-plaintext highlighter-rouge">f2</code> 使用，所以 <code class="language-plaintext highlighter-rouge">f1</code> 的作用域不会被回收，以供 <code class="language-plaintext highlighter-rouge">f2</code> 在之后的任意时间进行引用。</p>

<p><code class="language-plaintext highlighter-rouge">f2</code> 始终保持对 <code class="language-plaintext highlighter-rouge">f1</code> 作用域的引用，这个引用和 <code class="language-plaintext highlighter-rouge">f2</code> 本身就组成了闭包。</p>

<p>总结一下：</p>

<ul>
  <li>无论通过何种方式将内部函数传递到所在的词法作用域以外，这个函数都会保持对原始作用域的引用，这样就形成了闭包。</li>
  <li>无论在何处执行这个函数都会使用闭包，闭包使得函数可以继续访问定义时的词法作用域。</li>
</ul>

<p>所以，<strong>闭包 = 函数 + 外部作用域</strong>。</p>

<p>我们的代码中其实到处都是闭包，只是我们没有发现。</p>

<h3 id="函数柯里化">函数柯里化</h3>

<p>函数柯里化（curry）是函数式编程里面的概念。函数柯里化后，每次调用时只接受一部分参数，并返回一个函数，直到传递所有参数为止。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 柯里化之前</span>
<span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// 3</span>

<span class="c1">// 柯里化之后</span>
<span class="kd">function</span> <span class="nx">Add</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 3</span>
</code></pre></div></div>

<h3 id="回调函数-callback">回调函数 Callback</h3>

<ul>
  <li>定时器</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">wait</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">wait</span><span class="p">(</span><span class="dl">'</span><span class="s1">May the force be with you.</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>事件监听器</li>
  <li>数组常用方法 forEach、map…</li>
  <li>promise</li>
  <li>Ajax 请求</li>
</ul>

<h3 id="模块">模块</h3>

<p>模块是一个公共函数调用后返回内部私有函数和变量引用的一种代码模式。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Matrix</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name1</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Neo</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">name2</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Trinity</span><span class="dl">'</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">Neo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">Trinity</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name2</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">Neo</span><span class="p">,</span>
    <span class="nx">Trinity</span><span class="p">,</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">Matrix</span><span class="p">();</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">Neo</span><span class="p">();</span> <span class="c1">// 'Neo'</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Trinity</span><span class="p">();</span> <span class="c1">// 'Trinity'</span>
</code></pre></div></div>

<p>模块模式需要具备两个必要条件：</p>

<ul>
  <li>必须有外部的包装函数，该函数必须至少被调用一次，每次调用都会创建一个新的模块实例。</li>
  <li>包装函数必须返回至少一个内部函数，这样就会创建涵盖整个包装函数内部作用域的闭包。返回的内部函数就是模块的 API。</li>
</ul>

<p>ES6 之前的模块使用，以 jQuery 为例，我们使用 script 标签引入 jQuery 模块后，就可以直接使用模块中暴露的 <code class="language-plaintext highlighter-rouge">jQuery</code> <code class="language-plaintext highlighter-rouge">$</code> 等标识符。</p>

<p>除此之外，还可以依赖于模块加载器，比如基于 AMD （异步模块定义）实现的 <a href="https://requirejs.org/">RequireJS</a>，提供了 <code class="language-plaintext highlighter-rouge">require</code> <code class="language-plaintext highlighter-rouge">define</code> 方法用于引入模块和定义模块，定义模块的核心概念是这样的：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Modules</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">modules</span> <span class="o">=</span> <span class="p">{};</span>

  <span class="kd">function</span> <span class="nx">define</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">deps</span><span class="p">,</span> <span class="nx">impl</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">deps</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">deps</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">deps</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
    <span class="p">}</span>
    <span class="nx">modules</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">impl</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">impl</span><span class="p">,</span> <span class="nx">deps</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="kd">get</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">define</span><span class="p">,</span>
    <span class="kd">get</span><span class="p">,</span>
  <span class="p">};</span>
<span class="p">})();</span>
</code></pre></div></div>

<p>这里的包装函数是一个立即执行函数，执行后返回了包装函数内部定义的 <code class="language-plaintext highlighter-rouge">define</code> <code class="language-plaintext highlighter-rouge">get</code> 函数，这两个函数一直引用着包装函数的内部作用域，这样就产生了闭包。</p>

<p>ES6 为模块增加了语法支持，模块必须在独立的文件中定义，即一个文件一个模块，ES6 会将文件当作独立的模块来处理。每个模块可以导入其他模块的 API，也可以导出自己的 API。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Call</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">call.js</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Mr.Anderson</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Smith</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Call</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="nx">Smith</span><span class="p">;</span>
</code></pre></div></div>

<p>可以把整个文件看作是一个包装函数，导出的 <code class="language-plaintext highlighter-rouge">Smith</code> 函数一直引用着包装函数的内部作用域，形成闭包。</p>

<p>总结一下：</p>

<ul>
  <li>ES6 之前的模块是基于函数的模块，通过 RequireJS 这类模块加载器可以实现模块的异步加载。</li>
  <li>ES6 模块是基于文件的模块，因为是语法层面的支持，浏览器默认的模块加载器就可以异步加载模块文件。</li>
</ul>

<p>关于 JS 模块化，可以参考 MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">JavaScript 模块</a>。</p>

<p><img src="https://fehub.net/images/posts/2021/scope-closure-3.png" alt="image" /></p>

<h2 id="饭后甜点">饭后甜点</h2>

<ul>
  <li>下面这段代码的执行结果是什么？</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createFunctions</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">funcs</span> <span class="o">=</span> <span class="nx">createFunctions</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">funcs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">funcs</span><span class="p">[</span><span class="nx">i</span><span class="p">]());</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>回调函数的本质是闭包吗？</li>
  <li>创建一个函数就会形成闭包吗？</li>
</ul>

<h1 id="参考资料">参考资料</h1>

<ul>
  <li><a href="https://blog.csdn.net/qq_38836118/article/details/98878286/">JavaScript 到底是解释型语言还是编译型语言</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包 - MDN</a></li>
</ul>]]></content><author><name>Ji Chao</name></author><category term="一次搞懂系列" /><category term="JavaScript" /><summary type="html"><![CDATA[一次搞懂作用域和闭包]]></summary></entry><entry><title type="html">一次搞懂 rem 布局</title><link href="https://fehub.net/2021/01/02/rem/" rel="alternate" type="text/html" title="一次搞懂 rem 布局" /><published>2021-01-02T00:00:00+08:00</published><updated>2021-01-02T00:00:00+08:00</updated><id>https://fehub.net/2021/01/02/rem</id><content type="html" xml:base="https://fehub.net/2021/01/02/rem/"><![CDATA[<p>rem 弹性布局目前仍是移动端适配的主流方案，以前觉得 rem 布局就是等比缩放，很简单，然而真正把它讲明白却很难。写这篇文章的过程也是一次重新学习的过程。</p>

<h2 id="前言">前言</h2>

<p>在进入正题之前，首先认识几个名词，便于后续理解。</p>

<ul>
  <li>
    <p><strong>像素</strong></p>

    <p>像素是指组成图像的小方块，是整个图像中不可分割的最小单位，每个小方块都有一个明确的位置和被分配的色彩值。</p>
  </li>
  <li>
    <p><strong>分辨率</strong></p>

    <p>分辨率是指每一个方向上的像素数量，比如我们常说的 1920×1080 分辨率，就是指横向有 1920 个像素，竖向有 1080 个像素。描述分辨率的单位有：</p>

    <ul>
      <li>dpi - dots per inch，设备分辨率，又称输出分辨率，指的是设备每英寸上可产生的点数。</li>
      <li>ppi - pixels per inch，图像分辨率，又称像素密度单位，指的是每英寸所拥有的像素数量。</li>
      <li>lpi - lines per inch，网屏分辨率，线每英寸。</li>
      <li>ppd - pixels per degree，角分辨率，像素每度。</li>
    </ul>
  </li>
  <li>
    <p><strong>物理分辨率</strong></p>

    <p>物理分辨率是指液晶屏最高可显示的像素数，它是液晶屏固有的参数不能调节，表示方法与分辨率相同。一般来讲物理分辨率的大小可直接决定屏幕的最高分辨率，分辨率不会大于物理分辨率。</p>

    <p>比如说，一款物理分辨率为 1366x768 的液晶电视，号称<strong>兼容</strong> 1080P 的信号，其实是 1080P 的信号电视可以接收，但输出时只会按照液晶电视 1366x768 的物理分辨率进行输出。只有物理分辨率达到 1920x1080 的液晶电视才能<strong>支持</strong> 1080P 的信号输出。</p>
  </li>
  <li>
    <p><strong>设备像素 dp (Device Pixel)</strong></p>

    <p>物理像素，是指设备能控制显示的最小单位，我们常说的显示器 1920×1080 分辨率就是设备像素。</p>
  </li>
  <li>
    <p><strong>设备独立像素 dip (Device Independent Pixel)</strong></p>

    <p>逻辑像素，是指可以通过程序控制使用的虚拟像素，与设备无关，包括了 CSS 像素 px，iOS 的 pt，Android 的 dp 等。</p>

    <ul>
      <li>
        <p><strong>CSS 像素</strong></p>

        <p>CSS 像素是 Web 编程的概念，指的是 CSS 样式代码中使用的逻辑像素，是一个抽象概念，实际并不存在。</p>
      </li>
      <li>
        <p><strong>pt</strong></p>

        <p>pt 是苹果自定义的设计单位（不是绝对长度为 1/72 英寸的 pt）。第一代 iPhone 3G 的屏幕是 320x480 分辨率，163ppi，苹果规定在 163ppi 的时候 1pt = 1px，所以 1pt = (ppi/163)px（这里的 px 是屏幕的物理像素）。</p>

        <p>比如 iPhone 6 是 326ppi，那么 1pt = (326/163)px = 2px。iPhone 6 Plus 是 401ppi，计算得出 1pt = 2.46px，而实际是 3px，因为在图像呈现在屏幕之前做了一次采样处理。</p>
      </li>
      <li>
        <p><strong>dp</strong></p>

        <p>和苹果的 pt 一样，dp 是安卓为了设计而创造的独立单位，1dp = (ppi/160)px。</p>
      </li>
      <li>
        <p><strong>pt、dp 与 px 的关系</strong></p>

        <p>如果在 HTML head 中设置了 <code class="language-plaintext highlighter-rouge">&lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;</code>，此时 CSS 像素的显示尺寸和 Native APP 中 pt、dp 的显示尺寸相等。</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>devicePixelRatio (dpr)</strong></p>

    <p>设备像素 dp 和设备独立像素 dip 的比例，也就是 <code class="language-plaintext highlighter-rouge">dpr = dp / dip</code>，在浏览器中可以通过 <code class="language-plaintext highlighter-rouge">window.devicePixelRatio</code> 获取到对应设备的 dpr。</p>
  </li>
</ul>

<p>举个例子🌰：</p>

<p>iPhone 6 的屏幕参数是，4.7英寸（对角线）Retina 高清显示屏，750x1334 分辨率，326ppi。iPhone 6 的横向分辨率（设备像素）是 750px，dpr（devicePixelRatio）是 2，所以它横向的 CSS 像素（设备独立像素）为 375px。</p>

<p><img src="https://fehub.net/images/posts/2021/rem-1.jpg" alt="image" /></p>

<h2 id="进入正题">进入正题</h2>

<p>CSS 中有两种类型的长度，绝对长度和相对长度，绝对长度有我们常见的 px，pt（point）等，而 rem 是一个相对长度，另外还有 em，vw，vh 这些都是相对长度，这里不再赘述，具体请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units">CSS 的值与单位</a>。</p>

<p>rem 单位的意思是“根元素的字体大小”，即 html 元素的 font-size 是多少 px，1rem 就是多少 px。</p>

<p>如果我们按设计稿的尺寸用 px 为单位实现了一个页面，理论上只在设计稿对应分辨率的屏幕上看才是正好的，在更大或者更小的屏幕上看可能就不合适了，这时候我们就要用到 rem 布局通过放大或者缩小让页面适应当前的屏幕。</p>

<p>rem 布局是弹性布局的一种实现方式，弹性布局可以算作响应式布局的一种，但响应式布局不全是弹性布局。弹性布局强调等比缩放，100% 还原，rem 布局的本质就是等比缩放；响应式布局强调不同屏幕要有不同的显示，比如媒体查询。</p>

<h3 id="rem-布局原理">rem 布局原理</h3>

<p>以设计稿的尺寸（一般是宽度）为标准，我们定义一个数值代表此时的 1rem 是多少，因为 rem 的本质是等比缩放，我们可以得到：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>设计稿宽度 / 设计稿的 1rem = 页面视口宽度 / 页面的 1rem
</code></pre></div></div>

<p>这里的视口是指布局视口（layout viewport），在浏览器中可以通过 <code class="language-plaintext highlighter-rouge">window.innerWidth</code> 或 <code class="language-plaintext highlighter-rouge">document.documentElement.clientWidth</code> 获取视口宽度。具体请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Viewport_concepts">视口概念</a>。</p>

<p>然后我们可以计算出不同设备上页面对应的 1rem 的值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>页面的 1rem = 页面视口宽度 / (设计稿宽度 / 设计稿的 1rem)
</code></pre></div></div>

<p>其中，<code class="language-plaintext highlighter-rouge">设计稿宽度 / 设计稿的 1rem</code> 相当于以 1rem 为基准将设计稿平均分成了若干份，那么上边的式子我们可以理解为：把不同设备上页面的视口平均分成和设计稿相同的份数，每一份就是 1rem。</p>

<p>接下来，在浏览器渲染页面阶段，加载 CSS 之前，我们通过 <code class="language-plaintext highlighter-rouge">document.documentElement.clientWidth</code> 获取到当前设备上页面视口的宽度（CSS 像素），根据上面的公式动态计算出根元素的 font-size 值，然后通过 JS 动态把值赋给 html 元素。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">fontSize</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">clientWidth</span> <span class="o">/</span> <span class="mf">7.5</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">px</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p>在解析 CSS 时，浏览器会根据 html 元素的 font-size 值把 rem 值换算成适合自己的 px 值，这样就实现了使用一套 CSS 代码适配不同的设备。</p>

<p>举个例子🌰：</p>

<p>设计师按照 750px 的标准做设计稿，为了方便计算我们取 100px 为 1rem，那么设计稿的宽度就是 7.5rem，不同设备上页面对应的 1rem 的值就是页面视口宽度 / 7.5。iPhone6 横向的 CSS 像素为 375px，那么对应的 1rem 数值就是 375/7.5 = 50px。</p>

<h3 id="注意事项">注意事项</h3>

<ul>
  <li>
    <p>在实现 CSS 代码时，我们可以提前计算好 rem 值写在代码中，也可以直接按设计稿标注写 px，然后通过 CSS 处理器去转换，但要注意配置好 px2rem 的比例。</p>
  </li>
  <li>
    <p>HTML 中要对视口做如下设置：</p>
  </li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>有关 <code class="language-plaintext highlighter-rouge">&lt;meta name="viewport"&gt;</code> content 属性的值，可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name">标准元数据名称</a>。</p>

<h3 id="提出疑问">提出疑问</h3>

<p>到这里我们好像已经实现了使用 rem 布局来适配不同的设备，但是感觉还有点疑问。</p>

<p>设计师：设计稿是按照 iPhone 6 横向分辨率 750px 的标准给出的。</p>

<p>我：秋豆麻袋，iPhone 6 横向的 CSS 像素为 375px，所以说上边的例子我们实现的其实是两倍的 iPhone 6 的视图，应用在页面上时，首先经过了一次缩小的过程。总感觉怪怪的。</p>

<p>上边我们在 HTML 中设置了 <code class="language-plaintext highlighter-rouge">viewport</code>，其中的 <code class="language-plaintext highlighter-rouge">scale</code> 表示缩放比例，<code class="language-plaintext highlighter-rouge">width=device-width</code> 表示整个页面在设备上显示时的视口宽度（布局视口，CSS 像素）等于设备屏幕宽度（CSS 像素）。此时页面视口宽度的计算公式为：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">页面的视口宽度</span> <span class="o">=</span> <span class="nx">设备的物理分辨率</span> <span class="o">/</span> <span class="p">(</span><span class="nx">devicePixelRatio</span> <span class="o">*</span> <span class="nx">scale</span><span class="p">)</span>
</code></pre></div></div>

<p>如果 viewport 的 scale 根据 devicePixelRatio 动态设置：</p>

<ul>
  <li>当 devicePixelRatio 为 1 时，scale 为 1。</li>
  <li>当 devicePixelRatio 为 2 时，scale 为 0.5。</li>
  <li>当 devicePixelRatio 为 3 时，scale 为 0.3333。</li>
</ul>

<p>也就是说，devicePixelRatio * scale 始终等于 1，那么页面的视口宽度就和设备的物理分辨率始终相等。iPhone 6 的 devicePixelRatio 为 2，当 scale 为 0.5 时，iPhone 6 显示的页面视口宽度就和设计稿一样都是 750px 了。</p>

<p><img src="https://fehub.net/images/posts/2021/rem-2.jpg" alt="image" /></p>

<h3 id="网易的做法">网易的做法</h3>

<p>网易使用了我们上边说的 scale 固定为 1 的方法。以 iPhone 6 的 750px 设计稿为例：</p>

<ul>
  <li>
    <p>为了方便计算，以 100px 的 font-size 为参照，此时 1rem = 100px。</p>
  </li>
  <li>
    <p>计算设计稿的宽度为 750 / 100 = 7.5rem。</p>
  </li>
  <li>
    <p>通过以下代码动态设置 html 元素的 font-size：</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">fontSize</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">clientWidth</span> <span class="o">/</span> <span class="mf">7.5</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">px</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>写 CSS 代码时，各元素的 CSS 尺寸（rem 值）= 设计稿标注尺寸 / 100。</li>
</ul>

<h3 id="淘宝的做法">淘宝的做法</h3>

<p>淘宝使用了动态设置 scale 的方法，如上述所说根据设备的 devicePixelRatio 动态设置 scale 的值，使页面的视口宽度和设备的物理分辨率始终相等。还是以 iPhone 6 的 750px 设计稿为例：</p>

<ul>
  <li>
    <p>设定设计稿的宽度为 10rem。</p>
  </li>
  <li>
    <p>此时 html 元素的 font-size 值为 750 / 10 = 75px，即 1rem = 75px。</p>
  </li>
  <li>
    <p>动态设置 viewport 的 scale：</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">devicePixelRatio</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">meta[name="viewport"]</span><span class="dl">'</span><span class="p">).</span><span class="nx">setAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">content</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">initial-scale=</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">scale</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">, maximum-scale=</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">scale</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">, minimum-scale=</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">scale</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">, user-scalable=no</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>动态计算 html 元素的 font-size：</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">fontSize</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">clientWidth</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">px</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>写 CSS 代码时，各元素的 CSS 尺寸（rem 值）= 设计稿标注尺寸 / 75。</li>
</ul>

<h2 id="举一反三">举一反三</h2>

<h3 id="移动端和-pc-端的临界点">移动端和 PC 端的临界点</h3>

<p>通常情况下，移动端和 PC 端的页面不是同一种展示方式。如果我们按 iPhone 6 的标准实现页面，那么在 iPhone 6/7/8 Plus 等更大的屏幕上页面会等比放大，但当屏幕继续增大时，比如 iPad/PC 等，我们就没必要让它继续放大了，此时应该去访问 PC 网站。比如我们用手机访问百度看到的是移动端的页面，用 iPad 或者 PC 访问百度看到的则是电脑端的页面。</p>

<p>当页面的视口宽度大于某个值时，就可以让 html 元素的 font-size 不再变化了。动态设置 html 元素 font-size 的代码改动一下：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">deviceWidth</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">clientWidth</span><span class="p">;</span>
<span class="c1">// 980 只是举例，具体数值按需求确定</span>
<span class="k">if</span><span class="p">(</span><span class="nx">deviceWidth</span> <span class="o">&gt;</span> <span class="mi">980</span><span class="p">)</span> <span class="nx">deviceWidth</span> <span class="o">=</span> <span class="mi">980</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">fontSize</span> <span class="o">=</span> <span class="nx">deviceWidth</span> <span class="o">/</span> <span class="mf">7.5</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">px</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="工作中与设计师协作">工作中与设计师协作</h3>

<ul>
  <li>
    <p>视觉设计阶段，设计师按 750px 分辨率（iPhone 6/X）做设计稿。设计定稿后在 750px 的设计稿上做标注，输出标注图。同时等比放大 1.5 倍生成宽度 1125px 的设计稿，在 1125px 的稿子里切图。</p>
  </li>
  <li>
    <p>设计师输出宽度 750px 的设计标注图和 @2x/@3x 切图资源交付给前端开发工程师。</p>
  </li>
  <li>
    <p>开发工程师拿到标注图和切图资源，完成 iPhone 6/X（375pt）的界面开发。开发阶段用我们上面所说的 rem 布局实现。</p>
  </li>
  <li>
    <p>适配调试阶段，基于 iPhone 6/X 的界面效果，分别向上向下调试 iPhone 6/7/8 plus / iPhone 11（414pt），iPhone 12（390pt）和 iPhone 5S 及以下（320pt）的界面效果，由此完成大中小三屏适配。</p>
  </li>
</ul>

<p>以上。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://www.jianshu.com/p/af6dad66e49a">前端工程师需要明白的「像素」</a></li>
  <li><a href="https://www.cnblogs.com/jiangzilong/p/6700023.html">CSS 像素、设备独立像素、设备像素之间关系</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/70383462">基础 px、pt、ppi 的知识</a></li>
  <li><a href="https://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html">A pixel is not a pixel is not a pixel</a></li>
  <li><a href="https://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/">设备像素比 devicePixelRatio 简单介绍</a></li>
  <li><a href="http://t.zoukankan.com/wmhuang-p-6817057.html">针对 iPhone 的 pt、Android 的 dp、HTML 的 CSS 像素与 dpr、设计尺寸和物理像素的浅分析</a></li>
  <li><a href="https://blog.csdn.net/xwqqq/article/details/54862279">手机端 rem 布局详解</a></li>
</ul>]]></content><author><name>Ji Chao</name></author><category term="一次搞懂系列" /><category term="CSS" /><summary type="html"><![CDATA[一次搞懂 rem 布局]]></summary></entry><entry><title type="html">一次搞懂 JSON.stringify</title><link href="https://fehub.net/2020/12/12/json-stringify/" rel="alternate" type="text/html" title="一次搞懂 JSON.stringify" /><published>2020-12-12T00:00:00+08:00</published><updated>2020-12-12T00:00:00+08:00</updated><id>https://fehub.net/2020/12/12/json-stringify</id><content type="html" xml:base="https://fehub.net/2020/12/12/json-stringify/"><![CDATA[<p>在这里你可以找到 JSON.stringify 的所有常规和非常规的用法。</p>

<h2 id="前言">前言</h2>

<p>先看一个面试题：实现一个对象的 map 函数，类似 <code class="language-plaintext highlighter-rouge">Array.prototype.map</code>，先看答案，然后带着问题往下看。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_map</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">oThis</span> <span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">fn</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">fn</span><span class="p">}</span><span class="s2"> is not a function!`</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">oThis</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}));</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="na">d</span><span class="p">:</span> <span class="mi">5</span> <span class="p">};</span>

<span class="kd">const</span> <span class="nx">_obj</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">_map</span><span class="p">((</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">o</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">++</span><span class="nx">val</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_obj</span><span class="p">);</span> <span class="c1">// {a: 3, b: 4, c: 5, d: 6}</span>
</code></pre></div></div>

<p>这里用到了 <code class="language-plaintext highlighter-rouge">JSON.stringify()</code> 方法。通常情况下，我们对它的使用往往局限在对 Object 的序列化，或者使用它对 Object 进行深拷贝。这次我们一次搞懂 <code class="language-plaintext highlighter-rouge">JSON.stringify()</code> 的所有用法。</p>

<h2 id="jsonstringify">JSON.stringify()</h2>

<p><code class="language-plaintext highlighter-rouge">JSON.stringify()</code> 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span><span class="p">[,</span> <span class="nx">replacer</span> <span class="p">[,</span> <span class="nx">space</span><span class="p">]])</span>
</code></pre></div></div>

<h2 id="九个特性">九个特性</h2>

<p>如果只传一个参数，<code class="language-plaintext highlighter-rouge">JSON.stringify()</code> 将第一个参数的值转换为相应的 JSON 格式，有以下九个特性：</p>

<ul>
  <li>转换值如果有 <code class="language-plaintext highlighter-rouge">toJSON()</code> 方法，序列化的结果就是这个方法的返回值，忽略其他属性的值。</li>
  <li><code class="language-plaintext highlighter-rouge">Date</code> 对象包含 <code class="language-plaintext highlighter-rouge">toJSON()</code> 方法（同 <code class="language-plaintext highlighter-rouge">Date.toISOString()</code>），因此会被当做字符串处理。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Li Lei</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">toJSON</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">"</span><span class="s2">Han Meimei</span><span class="dl">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">})</span>
<span class="c1">// '"Han Meimei"'</span>

<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">());</span>
<span class="c1">// '"2020-12-05T09:11:20.566Z"'</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="na">now</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="p">});</span>
<span class="c1">// '{"now":"2020-12-05T09:11:20.566Z"}'</span>
</code></pre></div></div>

<ul>
  <li><strong>函数</strong>、<strong>undefined</strong> 以及 <strong>symbol</strong> 单独序列化时会转换为 <code class="language-plaintext highlighter-rouge">undefined</code>，作为数组元素序列化时会转换为 <code class="language-plaintext highlighter-rouge">null</code>，作为对象的属性值序列化时会被忽略。</li>
  <li>当 <strong>symbol</strong> 作为对象的<strong>属性键</strong>序列化时，该属性会被完全忽略掉，即使 <code class="language-plaintext highlighter-rouge">replacer</code> 参数中强制指定了包含它（<code class="language-plaintext highlighter-rouge">replacer</code> 参数我们稍后会说到），序列化时也会忽略。</li>
  <li>因为非数组对象序列化时会忽略一些特殊的值，所以对象的属性不能保证以特定的顺序出现在序列化后的字符串中，数组除外。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="kd">function</span><span class="p">(){});</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{});</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">stringify</span><span class="dl">'</span><span class="p">));</span>
<span class="c1">// undefined</span>

<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
  <span class="na">a</span><span class="p">:</span> <span class="dl">"</span><span class="s2">stringify</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="kc">undefined</span><span class="p">,</span>
  <span class="na">c</span><span class="p">:</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">stringify</span><span class="dl">"</span><span class="p">),</span>
  <span class="na">d</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">});</span>
<span class="c1">// '{"a":"stringify"}'</span>

<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([</span><span class="dl">"</span><span class="s2">stringify</span><span class="dl">"</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">stringify</span><span class="dl">"</span><span class="p">),</span> <span class="kd">function</span><span class="p">(){}]);</span>
<span class="c1">// '["stringify",null,null,null]'</span>

<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="p">[</span><span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">json</span><span class="dl">"</span><span class="p">)]:</span> <span class="dl">"</span><span class="s2">stringify</span><span class="dl">"</span> <span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">k</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">symbol</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">v</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="c1">// undefined</span>
</code></pre></div></div>

<ul>
  <li><strong>NaN</strong>、<strong>Infinity</strong> 格式的数值以及 <strong>null</strong> 都会被当做 <code class="language-plaintext highlighter-rouge">null</code>，单独序列化时会转换为字符串 <code class="language-plaintext highlighter-rouge">"null"</code>，作为数组元素以及对象的属性值序列化时都会转换为 <code class="language-plaintext highlighter-rouge">null</code>。对 <code class="language-plaintext highlighter-rouge">BigInt</code> 类型（大于 2^53-1 的任意大的整数）的值序列化时会抛出 <code class="language-plaintext highlighter-rouge">Uncaught TypeError: Do not know how to serialize a BigInt</code> 。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">);</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="c1">// "null"</span>

<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
  <span class="na">a</span><span class="p">:</span> <span class="kc">NaN</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="kc">Infinity</span><span class="p">,</span>
  <span class="na">c</span><span class="p">:</span> <span class="kc">null</span>
<span class="p">});</span>
<span class="c1">// '{"a":null,"b":null,"c":null}'</span>

<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([</span><span class="kc">NaN</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">null</span><span class="p">]);</span>
<span class="c1">// '[null,null,null]'</span>

<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="mi">1</span><span class="nx">n</span><span class="p">);</span>
<span class="c1">// Uncaught TypeError: Do not know how to serialize a BigInt</span>
</code></pre></div></div>

<ul>
  <li><strong>布尔值</strong>、<strong>数字</strong>、<strong>字符串</strong>的包装对象作为数组元素以及对象的属性值序列化时会自动转换成对应的原始值，单独序列化时会转化为对应的字符串。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="c1">// '1'</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="dl">"</span><span class="s2">false</span><span class="dl">"</span><span class="p">));</span>
<span class="c1">// '"false"'</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">));</span>
<span class="c1">// 'false'</span>

<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
	<span class="na">a</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="na">b</span><span class="p">:</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="dl">"</span><span class="s2">false</span><span class="dl">"</span><span class="p">),</span>
	<span class="na">c</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="p">});</span>
<span class="c1">// '{"a":1,"b":"false","c":false}'</span>

<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([</span><span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="dl">"</span><span class="s2">false</span><span class="dl">"</span><span class="p">),</span> <span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">)]);</span>
<span class="c1">// '[1,"false",false]'</span>
</code></pre></div></div>

<ul>
  <li>其他类型的对象，包括 <strong>Map</strong>/<strong>Set</strong>/<strong>WeakMap</strong>/<strong>WeakSet</strong>，仅会序列化可枚举的属性。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">json</span><span class="dl">'</span><span class="p">,</span> <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
    <span class="na">b</span><span class="p">:</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">stringify</span><span class="dl">'</span><span class="p">,</span> <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}</span>
  <span class="p">})</span>
<span class="p">);</span>
<span class="c1">// '{"b":"stringify"}'</span>
</code></pre></div></div>

<ul>
  <li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。当我们试图通过 <code class="language-plaintext highlighter-rouge">JSON.parse(JSON.stringify())</code> 方法实现深拷贝时，要注意对象不能包含循环引用，否则会报错。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Uncaught TypeError: Converting circular structure to JSON</span>
</code></pre></div></div>

<h2 id="第二个参数">第二个参数</h2>

<p>接下来看第二个和第三个参数。两个参数都是可选的。</p>

<p>第二个参数 <code class="language-plaintext highlighter-rouge">replacer</code> 可以是一个函数，也可以是一个数组。</p>

<ul>
  <li>当它是一个函数时，它有两个参数，键（key）和值（value），被序列化的值的每个属性都会经过该函数的处理，类似于数组方法 <code class="language-plaintext highlighter-rouge">map</code>、<code class="language-plaintext highlighter-rouge">filter</code> 等方法的回调函数。</li>
  <li>当它是一个数组时，只有数组中包含的属性名才会被序列化到 JSON 字符串中。</li>
  <li>当它是 null 或者未传时，对象所有的属性都会被序列化。</li>
</ul>

<p>通过 <code class="language-plaintext highlighter-rouge">replacer</code> 参数，我们可以打破上述九个特性中的一些特性。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span> <span class="dl">"</span><span class="s2">stringify</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="kc">undefined</span><span class="p">,</span>
  <span class="na">c</span><span class="p">:</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">"</span><span class="s2">stringify</span><span class="dl">"</span><span class="p">),</span>
  <span class="na">d</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 不用 replacer 参数时</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="c1">// '{"a":"stringify"}'</span>

<span class="c1">// 使用 replacer 参数时</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">undefined</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">"</span><span class="s2">undefined</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">case</span> <span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">symbol</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
    <span class="k">case</span> <span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">});</span>
<span class="c1">// '{"a":"stringify","b":"undefined","c":"Symbol(stringify)","d":"function() {}"}'</span>
</code></pre></div></div>

<p>需要注意的是，<code class="language-plaintext highlighter-rouge">replacer</code> 传入函数时，第一个参数不是对象的第一个键值对，而是空字符串作为 key 值，value 值是整个对象的键值对：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">});</span>
<span class="c1">// 第一个传入 replacer 函数的是 {"":{a:1,b:2,c:3}}</span>
<span class="c1">// { a: 1, b: 2, c: 3 }   </span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
<span class="c1">// 3</span>
</code></pre></div></div>

<p>这时候我们再返回开头看看实现 Object.map 的方法，是不是恍然大悟呢？</p>

<p>当 <code class="language-plaintext highlighter-rouge">replacer</code> 是一个数组时，很简单，只会序列化数组中包含的属性值。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="dl">"</span><span class="s2">JSON</span><span class="dl">"</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="dl">"</span><span class="s2">stringify</span><span class="dl">"</span> <span class="p">};</span>

<span class="c1">// 只保留 b 属性的值</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">b</span><span class="dl">"</span><span class="p">]);</span>
<span class="c1">// '{"b":"stringify"}'</span>
</code></pre></div></div>

<h2 id="第三个参数">第三个参数</h2>

<p>第三个参数 <code class="language-plaintext highlighter-rouge">space</code> 指定缩进用的空白字符串，用于美化输出，它可以是数字，也可以是字符串。这个参数用处不大。</p>

<ul>
  <li>如果参数是数字，代表缩进有多少个空格，最大是 10，小于 1 则没有空格。</li>
  <li>如果参数是字符串，那么这个字符串将作为缩进的空格，当字符串超过 10 个字母时，取它的前 10 个字母。</li>
  <li>如果参数没有或者为 null，将没有空格。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="dl">"</span><span class="s2">JSON</span><span class="dl">"</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="dl">"</span><span class="s2">stringify</span><span class="dl">"</span> <span class="p">};</span>

<span class="c1">// 缩进有 12 个空格</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
<span class="c1">// '{\n          "a": "JSON",\n          "b": "stringify"\n}'</span>

<span class="c1">// 用'a'代替缩进的空格</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// '{\na"a": "JSON",\na"b": "stringify"\n}'</span>
</code></pre></div></div>

<h2 id="举一反三">举一反三</h2>

<h3 id="json-对象">JSON 对象</h3>

<p><code class="language-plaintext highlighter-rouge">JSON</code> 是一种语法，用来序列化对象、数组、数值、字符串、布尔值和 <code class="language-plaintext highlighter-rouge">null</code> 。<code class="language-plaintext highlighter-rouge">JSON</code> 对象包含两个方法：<code class="language-plaintext highlighter-rouge">parse</code> 和 <code class="language-plaintext highlighter-rouge">stringify</code>。除了这两个方法，<code class="language-plaintext highlighter-rouge">JSON</code> 这个对象本身并没有其他作用，也不能被调用或者作为构造函数调用。</p>

<p><code class="language-plaintext highlighter-rouge">JSON</code> 基于 JavaScript 语法，但 JSON 不是 JavaScript，JavaScript 也不是 JSON。</p>

<ul>
  <li>对象和数组：属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号。</li>
  <li>数值：不能出现前导零；如果有小数点，后面至少跟着一位数字。</li>
  <li>字符串：字符串必须用双引号括起来。</li>
</ul>

<h3 id="jsonparse">JSON.parse()</h3>

<p><code class="language-plaintext highlighter-rouge">JSON.parse()</code> 方法用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。</p>

<h4 id="语法">语法</h4>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">text</span><span class="p">[,</span> <span class="nx">reviver</span><span class="p">])</span>
</code></pre></div></div>

<h4 id="参数">参数</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">text</code></strong></li>
</ul>

<p>要被解析成 JavaScript 值的字符串，必须符合 JSON 的语法格式。</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">reviver</code> 可选</strong></li>
</ul>

<p>转换器函数，如果传入该函数，可以用来修改解析生成的原始值，在 parse 返回之前调用。这个函数的遍历顺序从最内层开始，按照层级顺序，依次向外遍历，当遍历到最顶层的解析值时，传入 <code class="language-plaintext highlighter-rouge">reviver</code> 函数的参数是空字符串和当前的解析值（有可能已经被修改过了）。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">{"p": 5}</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">k</span> <span class="o">===</span> <span class="dl">''</span><span class="p">)</span> <span class="k">return</span> <span class="nx">v</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">v</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">});</span>
<span class="c1">// { p: 10 }</span>
</code></pre></div></div>

<h4 id="返回值">返回值</h4>

<ul>
  <li>Object 类型，对应给定 JSON 文本的对象/值。</li>
</ul>

<h4 id="异常">异常</h4>

<ul>
  <li>若传入的字符串不符合 JSON 规范，则会抛出 SyntaxError 异常。</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 不允许用逗号作为结尾</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">"</span><span class="s2">[1, 2, 3, 4, ]</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">{"foo" : 1, }</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>以上。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify() - MDN</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON">JSON - MDN</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse() - MDN</a></li>
  <li><a href="https://github.com/NieZhuZhu/Blog/issues/1">你不知道的 JSON.stringify() 的威力</a></li>
</ul>]]></content><author><name>Ji Chao</name></author><category term="一次搞懂系列" /><category term="JavaScript" /><summary type="html"><![CDATA[一次搞懂 JSON.stringify]]></summary></entry><entry><title type="html">推荐一些好用的 VSCode 扩展</title><link href="https://fehub.net/2020/10/18/vscode-extension/" rel="alternate" type="text/html" title="推荐一些好用的 VSCode 扩展" /><published>2020-10-18T00:00:00+08:00</published><updated>2020-10-18T00:00:00+08:00</updated><id>https://fehub.net/2020/10/18/vscode-extension</id><content type="html" xml:base="https://fehub.net/2020/10/18/vscode-extension/"><![CDATA[<p>VSCode（Visual Studio Code）作为代码编辑器，不仅开源、免费、颜值高，而且有丰富的扩展帮助我们提高开发效率，在前端开发中广受青睐。这篇文章总结了一些好用的扩展，不定期更新。</p>

<h3 id="chinese-simplified-简体中文-language-pack">Chinese (Simplified) (简体中文) Language Pack</h3>

<p>刚下载的 VSCode 默认是英文，可以选择安装官方的中文语言包。<a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">【传送门】</a></p>

<h3 id="更换主题">更换主题</h3>

<p><code class="language-plaintext highlighter-rouge">Command+Shift+P</code> 打开命令框，输入 color theme，进入主题列表，可以设置你喜欢的主题。</p>

<h3 id="添加代码片段">添加代码片段</h3>

<p><code class="language-plaintext highlighter-rouge">Command+Shift+P</code> 打开命令框，输入 user snippets，新建全局代码片段文件，在文件中设置代码片段。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">//</span><span class="w"> </span><span class="err">Example</span><span class="w">
  </span><span class="nl">"Print to console"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"scope"</span><span class="p">:</span><span class="w"> </span><span class="s2">"javascript,typescript"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"prefix"</span><span class="p">:</span><span class="w"> </span><span class="s2">"log"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"body"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="s2">"console.log('$1');"</span><span class="p">,</span><span class="w">
      </span><span class="s2">"$2"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Log output to console"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="auto-close-tag">Auto Close Tag</h3>

<p>输入 HTML 标签时自动关闭。<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag">【传送门】</a></p>

<p>比如，输入 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> 会自动填充后半部分 <code class="language-plaintext highlighter-rouge">&lt;/div&gt;</code>。</p>

<h3 id="auto-rename-tag">Auto Rename Tag</h3>

<p>修改 HTML 标签时自动修改整个标签。<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag">【传送门】</a></p>

<p>比如，我想把 <code class="language-plaintext highlighter-rouge">&lt;div&gt;&lt;/div&gt;</code> 修改为 <code class="language-plaintext highlighter-rouge">&lt;p&gt;&lt;/p&gt;</code>，只需要把第一个 div 修改为 p，第二个 div 会自动修改。</p>

<h3 id="highlight-matching-tag">Highlight Matching Tag</h3>

<p>突出显示匹配的开始和结束标签。<a href="https://marketplace.visualstudio.com/items?itemName=vincaslt.highlight-matching-tag">【传送门】</a></p>

<p>比如，一个闭合的标签 <code class="language-plaintext highlighter-rouge">&lt;div&gt;&lt;/div&gt;</code>，当把光标定位到第一个 <code class="language-plaintext highlighter-rouge">div</code> 上时，两个 <code class="language-plaintext highlighter-rouge">div</code> 都会高亮显示。当元素内部层级较多，开始和结束的两个标签相隔较远时，此扩展对于快速定位到某个闭合标签很有用处。</p>

<h3 id="css-peek">CSS Peek</h3>

<p><code class="language-plaintext highlighter-rouge">Command+点击</code> id 或 class 名可以从 HTML 文件定位到 CSS 文件对应位置。<a href="https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek">【传送门】</a></p>

<h3 id="autoprefixer">Autoprefixer</h3>

<p>自动给 CSS 代码添加兼容性前缀。<a href="https://marketplace.visualstudio.com/items?itemName=mrmlnc.vscode-autoprefixer">【传送门】</a></p>

<h3 id="image-preview">Image Preview</h3>

<p>引用图片时会在代码左侧显示图片的缩略图，方便预览。<a href="https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-preview">【传送门】</a></p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="sx">url('assets/play.png')</span> <span class="nb">no-repeat</span> <span class="nb">center</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="code-spell-checker">Code Spell Checker</h3>

<p>一个拼写检查器，帮助捕获常见的拼写错误。<a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker">【传送门】</a></p>

<h3 id="eslint">ESLint</h3>

<p>代码格式校验工具，配合项目中的校验规则，实现保存时格式化代码。<a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">【传送门】</a></p>

<h3 id="prettier">Prettier</h3>

<p>代码格式化工具，在项目中可以配置自己的格式化规则。<a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">【传送门】</a></p>

<h3 id="javascript-console-utils">Javascript console utils</h3>

<p>帮助插入和删除 <code class="language-plaintext highlighter-rouge">console.(*)</code> 语句。<a href="https://marketplace.visualstudio.com/items?itemName=whtouche.vscode-js-console-utils">【传送门】</a></p>

<ul>
  <li>选择一个变量 <code class="language-plaintext highlighter-rouge">test</code>，<code class="language-plaintext highlighter-rouge">Command+Shift+L</code> 会在下一行代码插入 <code class="language-plaintext highlighter-rouge">console.log('test', test)</code> 语句。</li>
  <li><code class="language-plaintext highlighter-rouge">Command+Shift+D</code> 将删除当前文档中的所有 <code class="language-plaintext highlighter-rouge">console.log</code> 语句。</li>
</ul>

<h3 id="korofileheader">koroFileHeader</h3>

<p>用于生成文件头部注释和函数注释。<a href="https://marketplace.visualstudio.com/items?itemName=OBKoro1.korofileheader">【传送门】</a></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Command+Shift+I</code> 生成文件头部注释。</li>
  <li><code class="language-plaintext highlighter-rouge">Command+Shift+T</code> 生成函数注释。</li>
</ul>

<h3 id="npm-intellisense">npm Intellisense</h3>

<p>在 import 语句中自动完成 npm 模块。<a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense">【传送门】</a></p>

<h3 id="path-intellisense">Path Intellisense</h3>

<p>自动识别文件路径，自动完成文件名。<a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">【传送门】</a></p>

<h3 id="import-cost">Import Cost</h3>

<p>在编辑器中显示 import/require 包的大小。<a href="https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost">【传送门】</a></p>

<h3 id="gitlens">GitLens</h3>

<p>可以查看每行代码的提交记录，包括提交人、提交时间、提交备注等。<a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">【传送门】</a></p>

<h3 id="git-history">Git History</h3>

<p>在 VSCode 中集成 Git 工具，可以查看 Git 日志、文件历史、比较分支或提交代码。<a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory">【传送门】</a></p>

<h3 id="git-graph">Git Graph</h3>

<p>类似于 SourceTree 的可视化版本控制插件，可以查看提交记录或执行 Git 操作。<a href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph">【传送门】</a></p>

<h3 id="todo-tree">Todo Tree</h3>

<p>在树形图中显示 TODO、FIXME 等注释标签。单击树形图中的注释标签将打开文件并将光标定位在包含注释标签的行上。<a href="https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree">【传送门】</a></p>

<p>安装插件后会在左侧菜单栏生成一个待办事项菜单，点击可以查看项目下注释标签的树形图。</p>

<p>以上。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
  <li><a href="https://blog.csdn.net/weixin_43363871/article/details/122041130">VScode 常用必备插件</a></li>
</ul>]]></content><author><name>Ji Chao</name></author><category term="VSCode" /><summary type="html"><![CDATA[推荐一些好用的 VSCode 扩展]]></summary></entry><entry><title type="html">图片加载出错的处理方式</title><link href="https://fehub.net/2020/08/08/img-load-error/" rel="alternate" type="text/html" title="图片加载出错的处理方式" /><published>2020-08-08T00:00:00+08:00</published><updated>2020-08-08T00:00:00+08:00</updated><id>https://fehub.net/2020/08/08/img-load-error</id><content type="html" xml:base="https://fehub.net/2020/08/08/img-load-error/"><![CDATA[<p>通常情况下，HTML 中的 img 标签加载出错后会默认显示一张裂开的图片，如果设置了 <code class="language-plaintext highlighter-rouge">alt</code> 属性，还会在默认图片后面显示 <code class="language-plaintext highlighter-rouge">alt</code> 属性的内容。</p>

<p>比如这张不存在的图片：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"https://fehub.net/images/xxx.png"</span> <span class="na">alt=</span><span class="s">"我是一张图片"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>在浏览器中的显示效果如图：</p>

<p><img src="https://fehub.net/images/posts/2020/img-load-error-1.png" alt="image" /></p>

<p>这种默认效果显得非常粗糙，对于用户也不太友好。</p>

<h3 id="使用默认图片占位">使用默认图片占位</h3>

<p>当图片加载出错的时候，使用一张默认图片（比如一张经过设计师设计的裂开的图片）进行占位，保证页面结构不会错乱。</p>

<p>实现方法如下：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"https://fehub.net/images/xxx.png"</span> <span class="na">alt=</span><span class="s">"我是一张图片"</span> <span class="na">onerror=</span><span class="s">"this.src='error.svg'"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="o">[</span><span class="nt">src</span><span class="err">$</span><span class="o">=</span><span class="s1">"error.svg"</span><span class="o">]</span> <span class="p">{</span>
  <span class="nl">object-fit</span><span class="p">:</span> <span class="n">contain</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里要注意 <code class="language-plaintext highlighter-rouge">error.svg</code> 必须可以访问到，否则会一直触发 <code class="language-plaintext highlighter-rouge">onerror</code> 进入死循环。</p>

<p>在浏览器中的显示效果如图：</p>

<p><img src="https://fehub.net/images/posts/2020/img-load-error-2.png" alt="image" /></p>

<h3 id="增加内容识别">增加内容识别</h3>

<p>当图片加载出错的时候，如果仅仅使用一张默认图片，用户其实并不能识别这张图片的含义。从用户的角度讲，最佳的实现方法应该兼顾视觉表现和内容识别。</p>

<p>实现方法如下：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"https://fehub.net/images/xxx.png"</span> <span class="na">alt=</span><span class="s">"我是一张图片"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-block</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">scale</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nt">img</span><span class="nd">::before</span> <span class="p">{</span>
  <span class="nl">content</span><span class="p">:</span> <span class="s2">' '</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="nb">absolute</span><span class="p">;</span>
  <span class="nl">left</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">top</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#f5f5f5</span> <span class="sx">url(error.svg)</span> <span class="nb">no-repeat</span> <span class="nb">center</span> <span class="p">/</span> <span class="m">50%</span> <span class="m">50%</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="nb">transparent</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">img</span><span class="nd">::after</span> <span class="p">{</span>
  <span class="nl">content</span><span class="p">:</span> <span class="n">attr</span><span class="p">(</span><span class="n">alt</span><span class="p">);</span>
  <span class="nl">position</span><span class="p">:</span> <span class="nb">absolute</span><span class="p">;</span>
  <span class="nl">left</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">bottom</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">line-height</span><span class="p">:</span> <span class="m">2</span><span class="p">;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="n">rgba</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">.5</span><span class="p">);</span>
  <span class="nl">color</span><span class="p">:</span> <span class="m">#ffffff</span><span class="p">;</span>
  <span class="nl">font-size</span><span class="p">:</span> <span class="m">12px</span><span class="p">;</span>
  <span class="nl">text-align</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
  <span class="nl">white-space</span><span class="p">:</span> <span class="nb">nowrap</span><span class="p">;</span>
  <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span>
  <span class="nl">text-overflow</span><span class="p">:</span> <span class="n">ellipsis</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在浏览器中的显示效果：</p>

<p><img src="https://fehub.net/images/posts/2020/img-load-error-3.png" alt="image" /></p>

<h3 id="实现用户没有头像时显示昵称的第一个汉字或字母">实现用户没有头像时显示昵称的第一个汉字或字母</h3>

<p>实现思路如下：</p>

<ul>
  <li>
    <p>如果 <code class="language-plaintext highlighter-rouge">img</code> 加载正常，<code class="language-plaintext highlighter-rouge">::before</code> 不会生效，利用这个特性在 <code class="language-plaintext highlighter-rouge">::before</code> 中实现没有头像时的显示效果。</p>
  </li>
  <li>
    <p>利用大字体大行高以及文字换行，在 <code class="language-plaintext highlighter-rouge">::before</code> 中实现只显示昵称的第一个字。</p>
  </li>
</ul>

<p>实现方法如下：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">class=</span><span class="s">"avatar"</span> <span class="na">src=</span><span class="s">"https://fehub.net/images/avatar.png"</span> <span class="na">alt=</span><span class="s">"FEHub"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span><span class="nc">.avatar</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">inline-block</span><span class="p">;</span>
  <span class="py">--s</span><span class="p">:</span> <span class="n">var</span><span class="p">(</span><span class="n">--size</span><span class="p">,</span> <span class="m">1.5rem</span><span class="p">);</span>
  <span class="nl">width</span><span class="p">:</span> <span class="n">var</span><span class="p">(</span><span class="n">--s</span><span class="p">);</span>
  <span class="nl">height</span><span class="p">:</span> <span class="n">var</span><span class="p">(</span><span class="n">--s</span><span class="p">);</span>
  <span class="nl">border-radius</span><span class="p">:</span> <span class="m">50%</span><span class="p">;</span>
  <span class="nl">white-space</span><span class="p">:</span> <span class="nb">normal</span><span class="p">;</span>
  <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">img</span><span class="nc">.avatar</span><span class="nd">::before</span> <span class="p">{</span>
  <span class="nl">content</span><span class="p">:</span> <span class="n">attr</span><span class="p">(</span><span class="n">alt</span><span class="p">);</span>
  <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
  <span class="nl">font-size</span><span class="p">:</span> <span class="n">calc</span><span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="n">--s</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span><span class="p">);</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="no">bisque</span><span class="p">;</span>
  <span class="nl">line-height</span><span class="p">:</span> <span class="n">var</span><span class="p">(</span><span class="n">--s</span><span class="p">);</span>
  <span class="nl">letter-spacing</span><span class="p">:</span> <span class="n">var</span><span class="p">(</span><span class="n">--s</span><span class="p">);</span>
  <span class="nl">text-indent</span><span class="p">:</span> <span class="n">var</span><span class="p">(</span><span class="n">--s</span><span class="p">);</span>
  <span class="nl">justify-content</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
  <span class="nl">text-align</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="nb">inherit</span><span class="p">;</span>
  <span class="nl">line-break</span><span class="p">:</span> <span class="n">anywhere</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在浏览器中的显示效果如图：</p>

<p><img src="https://fehub.net/images/posts/2020/img-load-error-4.png" alt="image" /></p>

<p><a href="https://fehub.net/demos/posts/2020/img-load-error.html">查看完整 demo</a></p>

<p>以上。</p>]]></content><author><name>Ji Chao</name></author><category term="HTML" /><category term="CSS" /><summary type="html"><![CDATA[图片加载出错的处理方式]]></summary></entry></feed>